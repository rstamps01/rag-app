"""
Enhanced WebSocket Monitoring Service - Corrected Version
========================================================
This module provides real-time monitoring capabilities for the RAG application
with comprehensive system metrics, GPU monitoring, and pipeline statistics.
"""

import asyncio
import json
import logging
import time
from datetime import datetime
from typing import Dict, List, Optional, Any

# Standard library imports
import os
import shutil

# Third-party imports with error handling
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False
    logging.warning("psutil not available - system metrics will be limited")

try:
    import GPUtil
    GPUTIL_AVAILABLE = True
except ImportError:
    GPUTIL_AVAILABLE = False
    logging.warning("GPUtil not available - GPU metrics will be limited")

# FastAPI imports with error handling
try:
    from fastapi import APIRouter, WebSocket, WebSocketDisconnect, HTTPException
    from fastapi.responses import JSONResponse
    FASTAPI_AVAILABLE = True
except ImportError:
    FASTAPI_AVAILABLE = False
    logging.error("FastAPI not available - WebSocket monitoring disabled")

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Create router only if FastAPI is available
if FASTAPI_AVAILABLE:
    router = APIRouter()
else:
    # Create a dummy router for import compatibility
    class DummyRouter:
        def websocket(self, *args, **kwargs):
            def decorator(func):
                return func
            return decorator
        
        def get(self, *args, **kwargs):
            def decorator(func):
                return func
            return decorator
    
    router = DummyRouter()

class EnhancedWebSocketManager:
    """Enhanced WebSocket connection manager with comprehensive monitoring"""
    
    def __init__(self):
        self.active_connections: List[WebSocket] = []
        self.monitoring_active = False
        self.monitoring_task = None
        self.metrics_history = []
        self.max_history_size = 100
        
    async def connect(self, websocket: WebSocket):
        """Accept WebSocket connection and start monitoring"""
        if not FASTAPI_AVAILABLE:
            logger.error("FastAPI not available - cannot accept WebSocket connection")
            return
            
        await websocket.accept()
        self.active_connections.append(websocket)
        logger.info(f"üîå WebSocket connected. Total connections: {len(self.active_connections)}")
        
        # Start monitoring if this is the first connection
        if len(self.active_connections) == 1 and not self.monitoring_active:
            await self.start_monitoring()
    
    def disconnect(self, websocket: WebSocket):
        """Remove WebSocket connection and stop monitoring if no connections"""
        if websocket in self.active_connections:
            self.active_connections.remove(websocket)
            logger.info(f"üîå WebSocket disconnected. Total connections: {len(self.active_connections)}")
        
        # Stop monitoring if no connections remain
        if len(self.active_connections) == 0 and self.monitoring_active:
            asyncio.create_task(self.stop_monitoring())
    
    async def start_monitoring(self):
        """Start the monitoring loop"""
        if self.monitoring_active:
            return
            
        self.monitoring_active = True
        self.monitoring_task = asyncio.create_task(self.monitoring_loop())
        logger.info("üöÄ Started monitoring task")
    
    async def stop_monitoring(self):
        """Stop the monitoring loop"""
        self.monitoring_active = False
        if self.monitoring_task:
            self.monitoring_task.cancel()
            try:
                await self.monitoring_task
            except asyncio.CancelledError:
                pass
        logger.info("üõë Stopped monitoring task")
    
    async def broadcast_message(self, message: dict):
        """Broadcast message to all connected clients"""
        if not self.active_connections:
            return
            
        message_str = json.dumps(message)
        disconnected = []
        
        for connection in self.active_connections:
            try:
                await connection.send_text(message_str)
            except Exception as e:
                logger.error(f"Error sending message to WebSocket: {e}")
                disconnected.append(connection)
        
        # Remove disconnected clients
        for connection in disconnected:
            self.disconnect(connection)
    
    def get_system_health(self) -> Dict[str, Any]:
        """Get comprehensive system health metrics"""
        if not PSUTIL_AVAILABLE:
            return {
                "cpu_percent": 0,
                "memory_percent": 0,
                "memory_available": "0GB",
                "error": "psutil not available"
            }
        
        try:
            # CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # Memory usage
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            memory_available = f"{memory.available / (1024**3):.1f}GB"
            
            return {
                "cpu_percent": round(cpu_percent, 1),
                "memory_percent": round(memory_percent, 1),
                "memory_available": memory_available
            }
        except Exception as e:
            logger.error(f"Error getting system health: {e}")
            return {
                "cpu_percent": 0,
                "memory_percent": 0,
                "memory_available": "0GB",
                "error": str(e)
            }
    
    def get_gpu_performance(self) -> List[Dict[str, Any]]:
        """Get GPU performance metrics"""
        if not GPUTIL_AVAILABLE:
            # Return mock RTX 5090 data when GPUtil is not available
            return [{
                "id": 0,
                "name": "RTX 5090 (simulated)",
                "utilization": 0,
                "memory_used": 0,
                "memory_total": 32768,  # 32GB
                "temperature": 0,
                "error": "GPUtil not available"
            }]
        
        try:
            gpus = GPUtil.getGPUs()
            gpu_data = []
            
            for gpu in gpus:
                gpu_data.append({
                    "id": gpu.id,
                    "name": gpu.name,
                    "utilization": round(gpu.load * 100, 1),
                    "memory_used": round(gpu.memoryUsed, 1),
                    "memory_total": round(gpu.memoryTotal, 1),
                    "temperature": round(gpu.temperature, 1) if gpu.temperature else 0
                })
            
            # If no GPUs found, return mock RTX 5090 data
            if not gpu_data:
                gpu_data.append({
                    "id": 0,
                    "name": "RTX 5090 (not detected)",
                    "utilization": 0,
                    "memory_used": 0,
                    "memory_total": 32768,
                    "temperature": 0
                })
            
            return gpu_data
        except Exception as e:
            logger.error(f"Error getting GPU performance: {e}")
            return [{
                "id": 0,
                "name": "RTX 5090 (error)",
                "utilization": 0,
                "memory_used": 0,
                "memory_total": 32768,
                "temperature": 0,
                "error": str(e)
            }]
    
    def get_network_stats(self) -> Dict[str, Any]:
        """Get network statistics"""
        if not PSUTIL_AVAILABLE:
            return {
                "bytes_sent": 0,
                "bytes_recv": 0,
                "packets_sent": 0,
                "packets_recv": 0,
                "error": "psutil not available"
            }
        
        try:
            net_io = psutil.net_io_counters()
            return {
                "bytes_sent": net_io.bytes_sent,
                "bytes_recv": net_io.bytes_recv,
                "packets_sent": net_io.packets_sent,
                "packets_recv": net_io.packets_recv
            }
        except Exception as e:
            logger.error(f"Error getting network stats: {e}")
            return {
                "bytes_sent": 0,
                "bytes_recv": 0,
                "packets_sent": 0,
                "packets_recv": 0,
                "error": str(e)
            }
    
    def get_disk_stats(self) -> Dict[str, Any]:
        """Get disk statistics"""
        if not PSUTIL_AVAILABLE:
            return {
                "disk_usage_percent": 0,
                "disk_free_gb": 0,
                "disk_total_gb": 0,
                "disk_read_mb": 0,
                "disk_write_mb": 0,
                "error": "psutil not available"
            }
        
        try:
            # Disk usage for root partition
            disk_usage = psutil.disk_usage('/')
            disk_usage_percent = (disk_usage.used / disk_usage.total) * 100
            disk_free_gb = disk_usage.free / (1024**3)
            disk_total_gb = disk_usage.total / (1024**3)
            
            # Disk I/O
            disk_io = psutil.disk_io_counters()
            disk_read_mb = disk_io.read_bytes / (1024**2) if disk_io else 0
            disk_write_mb = disk_io.write_bytes / (1024**2) if disk_io else 0
            
            return {
                "disk_usage_percent": round(disk_usage_percent, 1),
                "disk_free_gb": round(disk_free_gb, 1),
                "disk_total_gb": round(disk_total_gb, 1),
                "disk_read_mb": round(disk_read_mb, 1),
                "disk_write_mb": round(disk_write_mb, 1)
            }
        except Exception as e:
            logger.error(f"Error getting disk stats: {e}")
            return {
                "disk_usage_percent": 0,
                "disk_free_gb": 0,
                "disk_total_gb": 0,
                "disk_read_mb": 0,
                "disk_write_mb": 0,
                "error": str(e)
            }
    
    def get_pipeline_stats(self) -> Dict[str, Any]:
        """Get pipeline performance statistics"""
        # Mock pipeline statistics - replace with actual implementation
        return {
            "queries_per_minute": 12,
            "avg_response_time": 150,
            "active_queries": 3,
            "total_queries": 1247,
            "success_rate": 98.5
        }
    
    def get_connection_status(self) -> Dict[str, Any]:
        """Get connection status for all services"""
        return {
            "websocket_connections": len(self.active_connections),
            "backend_status": "connected",
            "database_status": "connected",
            "vector_db_status": "connected"
        }
    
    def get_enhanced_system_metrics(self) -> Dict[str, Any]:
        """Get comprehensive system metrics with proper field names"""
        try:
            metrics = {
                "system_health": self.get_system_health(),
                "gpu_performance": self.get_gpu_performance(),
                "pipeline_stats": self.get_pipeline_stats(),  # Correct field name
                "connection_status": self.get_connection_status(),
                "network_stats": self.get_network_stats(),
                "disk_stats": self.get_disk_stats(),
                "lastUpdate": datetime.now().isoformat()
            }
            
            # Add to history
            self.metrics_history.append(metrics)
            if len(self.metrics_history) > self.max_history_size:
                self.metrics_history.pop(0)
            
            return metrics
        except Exception as e:
            logger.error(f"Error getting enhanced system metrics: {e}")
            return {
                "system_health": {"cpu_percent": 0, "memory_percent": 0, "memory_available": "0GB"},
                "gpu_performance": [{"utilization": 0, "memory_used": 0, "memory_total": 32768, "temperature": 0, "name": "RTX 5090"}],
                "pipeline_stats": {"queries_per_minute": 0, "avg_response_time": 0, "active_queries": 0, "total_queries": 0, "success_rate": 100.0},
                "connection_status": {"websocket_connections": 0, "backend_status": "unknown", "database_status": "unknown", "vector_db_status": "unknown"},
                "network_stats": {"bytes_sent": 0, "bytes_recv": 0, "packets_sent": 0, "packets_recv": 0},
                "disk_stats": {"disk_usage_percent": 0, "disk_free_gb": 0, "disk_total_gb": 0, "disk_read_mb": 0, "disk_write_mb": 0},
                "lastUpdate": datetime.now().isoformat(),
                "error": str(e)
            }
    
    async def monitoring_loop(self):
        """Main monitoring loop that broadcasts metrics"""
        logger.info("üìä Enhanced monitoring loop started")
        
        while self.monitoring_active:
            try:
                # Get comprehensive metrics
                metrics = self.get_enhanced_system_metrics()
                
                # Broadcast to all connected clients
                await self.broadcast_message({
                    "type": "metrics_update",
                    "data": metrics,
                    "timestamp": time.time()
                })
                
                # Wait before next update
                await asyncio.sleep(2)  # Update every 2 seconds
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(5)  # Wait longer on error
        
        logger.info("üìä Enhanced monitoring loop stopped")

# Create global manager instance
manager = EnhancedWebSocketManager()

# WebSocket endpoint
if FASTAPI_AVAILABLE:
    @router.websocket("/ws/pipeline-monitoring")
    async def websocket_endpoint(websocket: WebSocket):
        """Enhanced WebSocket endpoint for real-time monitoring"""
        await manager.connect(websocket)
        
        try:
            # Send initial state
            initial_metrics = manager.get_enhanced_system_metrics()
            await websocket.send_text(json.dumps({
                "type": "initial_state",
                "data": initial_metrics,
                "timestamp": time.time()
            }))
            
            # Keep connection alive
            while True:
                try:
                    # Wait for client messages (ping/pong)
                    await asyncio.wait_for(websocket.receive_text(), timeout=30.0)
                except asyncio.TimeoutError:
                    # Send ping to keep connection alive
                    await websocket.send_text(json.dumps({
                        "type": "ping",
                        "timestamp": time.time()
                    }))
                
        except WebSocketDisconnect:
            logger.info("üîå WebSocket client disconnected")
        except Exception as e:
            logger.error(f"‚ùå WebSocket error: {e}")
        finally:
            manager.disconnect(websocket)

    @router.get("/ws/test")
    async def websocket_test():
        """Test endpoint to verify WebSocket service availability"""
        return JSONResponse({
            "status": "Enhanced WebSocket endpoint ready",
            "active_connections": len(manager.active_connections),
            "websocket_url": "/api/v1/ws/pipeline-monitoring",
            "monitoring_active": manager.monitoring_active,
            "data_transformation": "enhanced_v2",
            "features": [
                "Real-time GPU monitoring",
                "Comprehensive system metrics", 
                "Network and disk statistics",
                "Query performance tracking",
                "Corrected data format matching"
            ],
            "dependencies": {
                "psutil": PSUTIL_AVAILABLE,
                "GPUtil": GPUTIL_AVAILABLE,
                "fastapi": FASTAPI_AVAILABLE
            }
        })

    @router.get("/monitoring/status")
    async def monitoring_status():
        """Get current monitoring status and latest metrics"""
        try:
            metrics = manager.get_enhanced_system_metrics()
            return JSONResponse({
                "status": "active" if manager.monitoring_active else "inactive",
                "active_connections": len(manager.active_connections),
                "monitoring_active": manager.monitoring_active,
                "metrics": metrics,
                "history_size": len(manager.metrics_history),
                "dependencies": {
                    "psutil": PSUTIL_AVAILABLE,
                    "GPUtil": GPUTIL_AVAILABLE,
                    "fastapi": FASTAPI_AVAILABLE
                }
            })
        except Exception as e:
            logger.error(f"Error getting monitoring status: {e}")
            raise HTTPException(status_code=500, detail=str(e))

else:
    # Dummy endpoints when FastAPI is not available
    def websocket_endpoint(*args, **kwargs):
        logger.error("FastAPI not available - WebSocket endpoint disabled")
        return None
    
    def websocket_test():
        return {"error": "FastAPI not available"}
    
    def monitoring_status():
        return {"error": "FastAPI not available"}

# Export the router and manager
__all__ = ["router", "manager"]

